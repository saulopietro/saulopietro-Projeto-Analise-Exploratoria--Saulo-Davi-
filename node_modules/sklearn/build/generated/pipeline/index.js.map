{"version":3,"sources":["../../../src/generated/pipeline/FeatureUnion.ts","../../../src/generated/pipeline/Pipeline.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Concatenates results of multiple transformer objects.\n\n  This estimator applies a list of transformer objects in parallel to the input data, then concatenates the results. This is useful to combine several feature extraction mechanisms into a single transformer.\n\n  Parameters of the transformers may be set using its name and the parameter name separated by a ‘__’. A transformer may be replaced entirely by setting the parameter with its name to another transformer, removed by setting to ‘drop’ or disabled by setting to ‘passthrough’ (features are passed without transformation).\n\n  Read more in the [User Guide](https://scikit-learn.org/stable/modules/generated/../compose.html#feature-union).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.FeatureUnion.html)\n */\nexport class FeatureUnion {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      List of transformer objects to be applied to the data. The first half of each tuple is the name of the transformer. The transformer can be ‘drop’ for it to be ignored or can be ‘passthrough’ for features to be passed unchanged.\n     */\n    transformer_list?: any\n\n    /**\n      Number of jobs to run in parallel. `undefined` means 1 unless in a [`joblib.parallel_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.5.dev0)\") context. `\\-1` means using all processors. See [Glossary](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Multiplicative weights for features per transformer. Keys are transformer names, values the weights. Raises ValueError if key not present in `transformer_list`.\n     */\n    transformer_weights?: any\n\n    /**\n      If `true`, the time elapsed while fitting each transformer will be printed as it is completed.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n\n    /**\n      If `true`, [`get_feature_names_out`](https://scikit-learn.org/stable/modules/generated/#sklearn.pipeline.FeatureUnion.get_feature_names_out \"sklearn.pipeline.FeatureUnion.get_feature_names_out\") will prefix all feature names with the name of the transformer that generated that feature. If `false`, [`get_feature_names_out`](https://scikit-learn.org/stable/modules/generated/#sklearn.pipeline.FeatureUnion.get_feature_names_out \"sklearn.pipeline.FeatureUnion.get_feature_names_out\") will not prefix any feature names and will error if feature names are not unique.\n\n      @defaultValue `true`\n     */\n    verbose_feature_names_out?: boolean\n  }) {\n    this.id = `FeatureUnion${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This FeatureUnion instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('FeatureUnion.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.pipeline import FeatureUnion\ntry: bridgeFeatureUnion\nexcept NameError: bridgeFeatureUnion = {}\n`\n\n    // set up constructor params\n    await this._py\n      .ex`ctor_FeatureUnion = {'transformer_list': ${this.opts['transformer_list'] ?? undefined}, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'transformer_weights': ${this.opts['transformer_weights'] ?? undefined}, 'verbose': ${this.opts['verbose'] ?? undefined}, 'verbose_feature_names_out': ${this.opts['verbose_feature_names_out'] ?? undefined}}\n\nctor_FeatureUnion = {k: v for k, v in ctor_FeatureUnion.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeFeatureUnion[${this.id}] = FeatureUnion(**ctor_FeatureUnion)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeFeatureUnion[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit all transformers using X.\n   */\n  async fit(opts: {\n    /**\n      Input data, used to fit transformers.\n     */\n    X?: ArrayLike\n\n    /**\n      Targets for supervised learning.\n     */\n    y?: ArrayLike[]\n\n    /**\n      If `enable_metadata_routing=False` (default): Parameters directly passed to the `fit` methods of the sub-transformers.\n     */\n    fit_params?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FeatureUnion instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FeatureUnion must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_FeatureUnion_fit = {'X': ${opts['X'] ?? undefined}, 'y': np.array(${opts['y'] ?? undefined}) if ${opts['y'] !== undefined} else None, 'fit_params': ${opts['fit_params'] ?? undefined}}\n\npms_FeatureUnion_fit = {k: v for k, v in pms_FeatureUnion_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FeatureUnion_fit = bridgeFeatureUnion[${this.id}].fit(**pms_FeatureUnion_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FeatureUnion_fit.tolist() if hasattr(res_FeatureUnion_fit, 'tolist') else res_FeatureUnion_fit`\n  }\n\n  /**\n    Fit all transformers, transform the data and concatenate results.\n   */\n  async fit_transform(opts: {\n    /**\n      Input data to be transformed.\n     */\n    X?: ArrayLike\n\n    /**\n      Targets for supervised learning.\n     */\n    y?: ArrayLike[]\n\n    /**\n      If `enable_metadata_routing=False` (default): Parameters directly passed to the `fit` methods of the sub-transformers.\n     */\n    params?: any\n  }): Promise<ArrayLike | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This FeatureUnion instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FeatureUnion must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_FeatureUnion_fit_transform = {'X': ${opts['X'] ?? undefined}, 'y': np.array(${opts['y'] ?? undefined}) if ${opts['y'] !== undefined} else None, 'params': ${opts['params'] ?? undefined}}\n\npms_FeatureUnion_fit_transform = {k: v for k, v in pms_FeatureUnion_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FeatureUnion_fit_transform = bridgeFeatureUnion[${this.id}].fit_transform(**pms_FeatureUnion_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FeatureUnion_fit_transform.tolist() if hasattr(res_FeatureUnion_fit_transform, 'tolist') else res_FeatureUnion_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FeatureUnion instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureUnion must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_FeatureUnion_get_feature_names_out = {'input_features': ${opts['input_features'] ?? undefined}}\n\npms_FeatureUnion_get_feature_names_out = {k: v for k, v in pms_FeatureUnion_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FeatureUnion_get_feature_names_out = bridgeFeatureUnion[${this.id}].get_feature_names_out(**pms_FeatureUnion_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FeatureUnion_get_feature_names_out.tolist() if hasattr(res_FeatureUnion_get_feature_names_out, 'tolist') else res_FeatureUnion_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRouter`](https://scikit-learn.org/stable/modules/generated/sklearn.utils.metadata_routing.MetadataRouter.html#sklearn.utils.metadata_routing.MetadataRouter \"sklearn.utils.metadata_routing.MetadataRouter\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FeatureUnion instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureUnion must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_FeatureUnion_get_metadata_routing = {'routing': ${opts['routing'] ?? undefined}}\n\npms_FeatureUnion_get_metadata_routing = {k: v for k, v in pms_FeatureUnion_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FeatureUnion_get_metadata_routing = bridgeFeatureUnion[${this.id}].get_metadata_routing(**pms_FeatureUnion_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FeatureUnion_get_metadata_routing.tolist() if hasattr(res_FeatureUnion_get_metadata_routing, 'tolist') else res_FeatureUnion_get_metadata_routing`\n  }\n\n  /**\n    Set the output container when `\"transform\"` and `\"fit_transform\"` are called.\n\n    `set_output` will set the output of all estimators in `transformer_list`.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit_transform`.\n     */\n    transform?: 'default' | 'pandas' | 'polars'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FeatureUnion instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FeatureUnion must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_FeatureUnion_set_output = {'transform': ${opts['transform'] ?? undefined}}\n\npms_FeatureUnion_set_output = {k: v for k, v in pms_FeatureUnion_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FeatureUnion_set_output = bridgeFeatureUnion[${this.id}].set_output(**pms_FeatureUnion_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FeatureUnion_set_output.tolist() if hasattr(res_FeatureUnion_set_output, 'tolist') else res_FeatureUnion_set_output`\n  }\n\n  /**\n    Transform X separately by each transformer, concatenate results.\n   */\n  async transform(opts: {\n    /**\n      Input data to be transformed.\n     */\n    X?: ArrayLike\n\n    /**\n      Parameters routed to the `transform` method of the sub-transformers via the metadata routing API. See [Metadata Routing User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) for more details.\n     */\n    params?: any\n  }): Promise<ArrayLike | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error('This FeatureUnion instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('FeatureUnion must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_FeatureUnion_transform = {'X': ${opts['X'] ?? undefined}, 'params': ${opts['params'] ?? undefined}}\n\npms_FeatureUnion_transform = {k: v for k, v in pms_FeatureUnion_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_FeatureUnion_transform = bridgeFeatureUnion[${this.id}].transform(**pms_FeatureUnion_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_FeatureUnion_transform.tolist() if hasattr(res_FeatureUnion_transform, 'tolist') else res_FeatureUnion_transform`\n  }\n\n  /**\n    Dictionary-like object, with the following attributes. Read-only attribute to access any transformer parameter by user given name. Keys are transformer names and values are transformer parameters.\n   */\n  get named_transformers(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This FeatureUnion instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'FeatureUnion must call init() before accessing named_transformers'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_FeatureUnion_named_transformers = bridgeFeatureUnion[${this.id}].named_transformers`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_FeatureUnion_named_transformers.tolist() if hasattr(attr_FeatureUnion_named_transformers, 'tolist') else attr_FeatureUnion_named_transformers`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  A sequence of data transformers with an optional final predictor.\n\n  `Pipeline` allows you to sequentially apply a list of transformers to preprocess the data and, if desired, conclude the sequence with a final [predictor](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-predictor) for predictive modeling.\n\n  Intermediate steps of the pipeline must be ‘transforms’, that is, they must implement `fit` and `transform` methods. The final [estimator](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-estimator) only needs to implement `fit`. The transformers in the pipeline can be cached using `memory` argument.\n\n  The purpose of the pipeline is to assemble several steps that can be cross-validated together while setting different parameters. For this, it enables setting parameters of the various steps using their names and the parameter name separated by a `'__'`, as in the example below. A step’s estimator may be replaced entirely by setting the parameter with its name to another estimator, or a transformer removed by setting it to `'passthrough'` or `undefined`.\n\n  For an example use case of `Pipeline` combined with [`GridSearchCV`](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html#sklearn.model_selection.GridSearchCV \"sklearn.model_selection.GridSearchCV\"), refer to [Selecting dimensionality reduction with Pipeline and GridSearchCV](https://scikit-learn.org/stable/modules/generated/../../auto_examples/compose/plot_compare_reduction.html#sphx-glr-auto-examples-compose-plot-compare-reduction-py). The example [Pipelining: chaining a PCA and a logistic regression](https://scikit-learn.org/stable/modules/generated/../../auto_examples/compose/plot_digits_pipe.html#sphx-glr-auto-examples-compose-plot-digits-pipe-py) shows how to grid search on a pipeline using `'__'` as a separator in the parameter names.\n\n  Read more in the [User Guide](https://scikit-learn.org/stable/modules/generated/../compose.html#pipeline).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html)\n */\nexport class Pipeline {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      List of (name of step, estimator) tuples that are to be chained in sequential order. To be compatible with the scikit-learn API, all steps must define `fit`. All non-last steps must also define `transform`. See [Combining Estimators](https://scikit-learn.org/stable/modules/generated/../compose.html#combining-estimators) for more details.\n     */\n    steps?: any\n\n    /**\n      Used to cache the fitted transformers of the pipeline. The last step will never be cached, even if it is a transformer. By default, no caching is performed. If a string is given, it is the path to the caching directory. Enabling caching triggers a clone of the transformers before fitting. Therefore, the transformer instance given to the pipeline cannot be inspected directly. Use the attribute `named_steps` or `steps` to inspect estimators within the pipeline. Caching the transformers is advantageous when fitting is time consuming.\n     */\n    memory?: string\n\n    /**\n      If `true`, the time elapsed while fitting each step will be printed as it is completed.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n  }) {\n    this.id = `Pipeline${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('Pipeline.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.pipeline import Pipeline\ntry: bridgePipeline\nexcept NameError: bridgePipeline = {}\n`\n\n    // set up constructor params\n    await this._py\n      .ex`ctor_Pipeline = {'steps': ${this.opts['steps'] ?? undefined}, 'memory': ${this.opts['memory'] ?? undefined}, 'verbose': ${this.opts['verbose'] ?? undefined}}\n\nctor_Pipeline = {k: v for k, v in ctor_Pipeline.items() if v is not None}`\n\n    await this._py.ex`bridgePipeline[${this.id}] = Pipeline(**ctor_Pipeline)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgePipeline[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Transform the data, and apply `decision_function` with the final estimator.\n\n    Call `transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `decision_function` method. Only valid if the final estimator implements `decision_function`.\n   */\n  async decision_function(opts: {\n    /**\n      Data to predict on. Must fulfill input requirements of first step of the pipeline.\n     */\n    X?: any\n\n    /**\n      Parameters requested and accepted by steps. Each step must have requested certain metadata for these parameters to be forwarded to them.\n     */\n    params?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Pipeline must call init() before decision_function()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_decision_function = {'X': ${opts['X'] ?? undefined}, 'params': ${opts['params'] ?? undefined}}\n\npms_Pipeline_decision_function = {k: v for k, v in pms_Pipeline_decision_function.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_decision_function = bridgePipeline[${this.id}].decision_function(**pms_Pipeline_decision_function)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_decision_function.tolist() if hasattr(res_Pipeline_decision_function, 'tolist') else res_Pipeline_decision_function`\n  }\n\n  /**\n    Fit the model.\n\n    Fit all the transformers one after the other and sequentially transform the data. Finally, fit the transformed data using the final estimator.\n   */\n  async fit(opts: {\n    /**\n      Training data. Must fulfill input requirements of first step of the pipeline.\n     */\n    X?: any\n\n    /**\n      Training targets. Must fulfill label requirements for all steps of the pipeline.\n     */\n    y?: any\n\n    /**\n      If `enable_metadata_routing=False` (default):\n     */\n    params?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Pipeline must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_fit = {'X': ${opts['X'] ?? undefined}, 'y': ${opts['y'] ?? undefined}, 'params': ${opts['params'] ?? undefined}}\n\npms_Pipeline_fit = {k: v for k, v in pms_Pipeline_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_fit = bridgePipeline[${this.id}].fit(**pms_Pipeline_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_fit.tolist() if hasattr(res_Pipeline_fit, 'tolist') else res_Pipeline_fit`\n  }\n\n  /**\n    Transform the data, and apply `fit_predict` with the final estimator.\n\n    Call `fit_transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `fit_predict` method. Only valid if the final estimator implements `fit_predict`.\n   */\n  async fit_predict(opts: {\n    /**\n      Training data. Must fulfill input requirements of first step of the pipeline.\n     */\n    X?: any\n\n    /**\n      Training targets. Must fulfill label requirements for all steps of the pipeline.\n     */\n    y?: any\n\n    /**\n      If `enable_metadata_routing=False` (default):\n     */\n    params?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Pipeline must call init() before fit_predict()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_fit_predict = {'X': ${opts['X'] ?? undefined}, 'y': ${opts['y'] ?? undefined}, 'params': ${opts['params'] ?? undefined}}\n\npms_Pipeline_fit_predict = {k: v for k, v in pms_Pipeline_fit_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_fit_predict = bridgePipeline[${this.id}].fit_predict(**pms_Pipeline_fit_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_fit_predict.tolist() if hasattr(res_Pipeline_fit_predict, 'tolist') else res_Pipeline_fit_predict`\n  }\n\n  /**\n    Fit the model and transform with the final estimator.\n\n    Fit all the transformers one after the other and sequentially transform the data. Only valid if the final estimator either implements `fit_transform` or `fit` and `transform`.\n   */\n  async fit_transform(opts: {\n    /**\n      Training data. Must fulfill input requirements of first step of the pipeline.\n     */\n    X?: any\n\n    /**\n      Training targets. Must fulfill label requirements for all steps of the pipeline.\n     */\n    y?: any\n\n    /**\n      If `enable_metadata_routing=False` (default):\n     */\n    params?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Pipeline must call init() before fit_transform()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_fit_transform = {'X': ${opts['X'] ?? undefined}, 'y': ${opts['y'] ?? undefined}, 'params': ${opts['params'] ?? undefined}}\n\npms_Pipeline_fit_transform = {k: v for k, v in pms_Pipeline_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_fit_transform = bridgePipeline[${this.id}].fit_transform(**pms_Pipeline_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_fit_transform.tolist() if hasattr(res_Pipeline_fit_transform, 'tolist') else res_Pipeline_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n\n    Transform input features using the pipeline.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'Pipeline must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_get_feature_names_out = {'input_features': ${opts['input_features'] ?? undefined}}\n\npms_Pipeline_get_feature_names_out = {k: v for k, v in pms_Pipeline_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_get_feature_names_out = bridgePipeline[${this.id}].get_feature_names_out(**pms_Pipeline_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_get_feature_names_out.tolist() if hasattr(res_Pipeline_get_feature_names_out, 'tolist') else res_Pipeline_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRouter`](https://scikit-learn.org/stable/modules/generated/sklearn.utils.metadata_routing.MetadataRouter.html#sklearn.utils.metadata_routing.MetadataRouter \"sklearn.utils.metadata_routing.MetadataRouter\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Pipeline must call init() before get_metadata_routing()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_get_metadata_routing = {'routing': ${opts['routing'] ?? undefined}}\n\npms_Pipeline_get_metadata_routing = {k: v for k, v in pms_Pipeline_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_get_metadata_routing = bridgePipeline[${this.id}].get_metadata_routing(**pms_Pipeline_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_get_metadata_routing.tolist() if hasattr(res_Pipeline_get_metadata_routing, 'tolist') else res_Pipeline_get_metadata_routing`\n  }\n\n  /**\n    Apply `inverse_transform` for each step in a reverse order.\n\n    All estimators in the pipeline must support `inverse_transform`.\n   */\n  async inverse_transform(opts: {\n    /**\n      Data samples, where `n_samples` is the number of samples and `n_features` is the number of features. Must fulfill input requirements of last step of pipeline’s `inverse_transform` method.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Data samples, where `n_samples` is the number of samples and `n_features` is the number of features. Must fulfill input requirements of last step of pipeline’s `inverse_transform` method.\n     */\n    Xt?: ArrayLike[]\n\n    /**\n      Parameters requested and accepted by steps. Each step must have requested certain metadata for these parameters to be forwarded to them.\n     */\n    params?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Pipeline must call init() before inverse_transform()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_inverse_transform = {'X': np.array(${opts['X'] ?? undefined}) if ${opts['X'] !== undefined} else None, 'Xt': np.array(${opts['Xt'] ?? undefined}) if ${opts['Xt'] !== undefined} else None, 'params': ${opts['params'] ?? undefined}}\n\npms_Pipeline_inverse_transform = {k: v for k, v in pms_Pipeline_inverse_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_inverse_transform = bridgePipeline[${this.id}].inverse_transform(**pms_Pipeline_inverse_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_inverse_transform.tolist() if hasattr(res_Pipeline_inverse_transform, 'tolist') else res_Pipeline_inverse_transform`\n  }\n\n  /**\n    Transform the data, and apply `predict` with the final estimator.\n\n    Call `transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `predict` method. Only valid if the final estimator implements `predict`.\n   */\n  async predict(opts: {\n    /**\n      Data to predict on. Must fulfill input requirements of first step of the pipeline.\n     */\n    X?: any\n\n    /**\n      If `enable_metadata_routing=False` (default):\n     */\n    params?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Pipeline must call init() before predict()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_predict = {'X': ${opts['X'] ?? undefined}, 'params': ${opts['params'] ?? undefined}}\n\npms_Pipeline_predict = {k: v for k, v in pms_Pipeline_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_predict = bridgePipeline[${this.id}].predict(**pms_Pipeline_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_predict.tolist() if hasattr(res_Pipeline_predict, 'tolist') else res_Pipeline_predict`\n  }\n\n  /**\n    Transform the data, and apply `predict_log_proba` with the final estimator.\n\n    Call `transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `predict_log_proba` method. Only valid if the final estimator implements `predict_log_proba`.\n   */\n  async predict_log_proba(opts: {\n    /**\n      Data to predict on. Must fulfill input requirements of first step of the pipeline.\n     */\n    X?: any\n\n    /**\n      If `enable_metadata_routing=False` (default):\n     */\n    params?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Pipeline must call init() before predict_log_proba()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_predict_log_proba = {'X': ${opts['X'] ?? undefined}, 'params': ${opts['params'] ?? undefined}}\n\npms_Pipeline_predict_log_proba = {k: v for k, v in pms_Pipeline_predict_log_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_predict_log_proba = bridgePipeline[${this.id}].predict_log_proba(**pms_Pipeline_predict_log_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_predict_log_proba.tolist() if hasattr(res_Pipeline_predict_log_proba, 'tolist') else res_Pipeline_predict_log_proba`\n  }\n\n  /**\n    Transform the data, and apply `predict_proba` with the final estimator.\n\n    Call `transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `predict_proba` method. Only valid if the final estimator implements `predict_proba`.\n   */\n  async predict_proba(opts: {\n    /**\n      Data to predict on. Must fulfill input requirements of first step of the pipeline.\n     */\n    X?: any\n\n    /**\n      If `enable_metadata_routing=False` (default):\n     */\n    params?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Pipeline must call init() before predict_proba()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_predict_proba = {'X': ${opts['X'] ?? undefined}, 'params': ${opts['params'] ?? undefined}}\n\npms_Pipeline_predict_proba = {k: v for k, v in pms_Pipeline_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_predict_proba = bridgePipeline[${this.id}].predict_proba(**pms_Pipeline_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_predict_proba.tolist() if hasattr(res_Pipeline_predict_proba, 'tolist') else res_Pipeline_predict_proba`\n  }\n\n  /**\n    Transform the data, and apply `score` with the final estimator.\n\n    Call `transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `score` method. Only valid if the final estimator implements `score`.\n   */\n  async score(opts: {\n    /**\n      Data to predict on. Must fulfill input requirements of first step of the pipeline.\n     */\n    X?: any\n\n    /**\n      Targets used for scoring. Must fulfill label requirements for all steps of the pipeline.\n     */\n    y?: any\n\n    /**\n      If not `undefined`, this argument is passed as `sample_weight` keyword argument to the `score` method of the final estimator.\n     */\n    sample_weight?: ArrayLike\n\n    /**\n      Parameters requested and accepted by steps. Each step must have requested certain metadata for these parameters to be forwarded to them.\n     */\n    params?: any\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Pipeline must call init() before score()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_score = {'X': ${opts['X'] ?? undefined}, 'y': ${opts['y'] ?? undefined}, 'sample_weight': ${opts['sample_weight'] ?? undefined}, 'params': ${opts['params'] ?? undefined}}\n\npms_Pipeline_score = {k: v for k, v in pms_Pipeline_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_score = bridgePipeline[${this.id}].score(**pms_Pipeline_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_score.tolist() if hasattr(res_Pipeline_score, 'tolist') else res_Pipeline_score`\n  }\n\n  /**\n    Transform the data, and apply `score_samples` with the final estimator.\n\n    Call `transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `score_samples` method. Only valid if the final estimator implements `score_samples`.\n   */\n  async score_samples(opts: {\n    /**\n      Data to predict on. Must fulfill input requirements of first step of the pipeline.\n     */\n    X?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Pipeline must call init() before score_samples()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_score_samples = {'X': ${opts['X'] ?? undefined}}\n\npms_Pipeline_score_samples = {k: v for k, v in pms_Pipeline_score_samples.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_score_samples = bridgePipeline[${this.id}].score_samples(**pms_Pipeline_score_samples)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_score_samples.tolist() if hasattr(res_Pipeline_score_samples, 'tolist') else res_Pipeline_score_samples`\n  }\n\n  /**\n    Set the output container when `\"transform\"` and `\"fit_transform\"` are called.\n\n    Calling `set_output` will set the output of all estimators in `steps`.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit_transform`.\n     */\n    transform?: 'default' | 'pandas' | 'polars'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Pipeline must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_set_output = {'transform': ${opts['transform'] ?? undefined}}\n\npms_Pipeline_set_output = {k: v for k, v in pms_Pipeline_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_set_output = bridgePipeline[${this.id}].set_output(**pms_Pipeline_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_set_output.tolist() if hasattr(res_Pipeline_set_output, 'tolist') else res_Pipeline_set_output`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Pipeline must call init() before set_score_request()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_set_score_request = {'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_Pipeline_set_score_request = {k: v for k, v in pms_Pipeline_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_set_score_request = bridgePipeline[${this.id}].set_score_request(**pms_Pipeline_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_set_score_request.tolist() if hasattr(res_Pipeline_set_score_request, 'tolist') else res_Pipeline_set_score_request`\n  }\n\n  /**\n    Transform the data, and apply `transform` with the final estimator.\n\n    Call `transform` of each transformer in the pipeline. The transformed data are finally passed to the final estimator that calls `transform` method. Only valid if the final estimator implements `transform`.\n\n    This also works where final estimator is `undefined` in which case all prior transformations are applied.\n   */\n  async transform(opts: {\n    /**\n      Data to transform. Must fulfill input requirements of first step of the pipeline.\n     */\n    X?: any\n\n    /**\n      Parameters requested and accepted by steps. Each step must have requested certain metadata for these parameters to be forwarded to them.\n     */\n    params?: any\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error('This Pipeline instance has already been disposed')\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('Pipeline must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_Pipeline_transform = {'X': ${opts['X'] ?? undefined}, 'params': ${opts['params'] ?? undefined}}\n\npms_Pipeline_transform = {k: v for k, v in pms_Pipeline_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_Pipeline_transform = bridgePipeline[${this.id}].transform(**pms_Pipeline_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_Pipeline_transform.tolist() if hasattr(res_Pipeline_transform, 'tolist') else res_Pipeline_transform`\n  }\n}\n"],"mappings":"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","names":["crypto"]}